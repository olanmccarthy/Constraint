import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.search.measure.MeasuresRecorder;
import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;

/*
 * A general version of the magic Square problem
 *   - now we allow the square to be any size
 *   - which means we must compute the value of the row sum as input to the problem
 *   - and we use a matrix (or 2D array) of variables
 *   Here, I have hard-coded the square size as the value of n
 *   You could, of course, read this in from the command line instead
 */
public class MagicSquare2 {

   public static void main(String[] args) {

      // Create a Model
      Model model = new Model("Magic Square General");


      // Create variables
      int n=6;   //n is the length of the side of the square
      int T = n*(n*n + 1)/2;    //T is the sum for each row, column or diagonal
      System.out.println("Square length = " + n + "; Target = " + T);

      //create a 2D array of IntVars for the square
      IntVar[][] square = model.intVarMatrix("square",  n,  n,  1,  n*n);

      //create an IntVar for the target, since it is required for the sum constraint
      IntVar target = model.intVar("target", T);

      //now create references to the decision variables, in different arrays, 
      //to make it easier to write the constraints
      //This is because it is easy in Java to talk about a row of a 2D array (just use the first index)
      //but it is not easy to refer to a column
      //So we create the transpose of the matrix, and talk about its rows instead.
      //Choco provides a set of helper methods in chocosolver.util.tools.ArrayUtils
      //We create special arrays for the diagonal cells.
      //Note: none of these are creating new CSP variables, just new references to the original vars
      IntVar[] flatVars = ArrayUtils.flatten(square);
      IntVar[][] transpose = ArrayUtils.transpose(square);

      IntVar[] diagdown = new IntVar[n];
      IntVar[] diagup = new IntVar[n];
      for (int row = 0; row<n; row++) {
         diagdown[row] = square[row][row];
         diagup[row] = square[(n-1)-row][row];
      }

      //now post the constraints on the rows, columns and diagonals
      for (int row = 0; row<n; row++) {
         model.sum(square[row], "=", target).post();
         model.sum(transpose[row], "=", target).post();
      }
      model.sum(diagdown, "=", target).post();
      model.sum(diagup, "=", target).post();


      //now make sure that all values are different
      model.allDifferent(flatVars).post();

      //breaking symmetries, to reduce search
      /**/
      model.arithm(square[0][0], "<", square[n-1][n-1]).post();
      model.arithm(square[0][0], "<", square[0][n-1]).post();
      model.arithm(square[0][0], "<", square[n-1][0]).post();
      
      model.arithm(square[0][n-1], "<", square[n-1][0]).post();
      /**/

      // Solve the problem
      Solver solver = model.getSolver();

      //varying search strategy to speed things up

      //solver.setSearch(Search.domOverWDegSearch(flatVars));
      //solver.setSearch(Search.inputOrderLBSearch(flatVars));
      solver.setSearch(Search.activityBasedSearch(flatVars)); 		//Do not search for all solutions to a CSP using activityBased -- see below 
      //solver.setSearch(new ImpactBased(flatVars, true));
      
      //Note: the Search class provides some ready-packaged strategies, generated by helper methods.
      //You can also define your own search strategy, and we will see later in the module what this would involve.
      //The Impacts strategy is defined as a class in the source code, but is not offered as a pre-packaged helper method
      //(I don't know why)

      //ActivityBasedSearch restarts after each solution, and so will discover again solutions it has already reported
      //Either impose a limit on the number of solutions, or on the time
      //Maximising or minimising works OK, since solutions must improve each iteration.
      //Searching for a single solution works OK.


      if (solver.solve()) {
      //while (solver.solve()) { //print the solution
         System.out.println("Solution " + solver.getSolutionCount() + ":");
         for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
               System.out.print(square[row][col] + " ");
            }
            System.out.println();
         }
         System.out.println();
      }
      //System.out.println("No more solutions");

      else {
         System.out.println("NO SOLUTION");
      }
      //MeasuresRecorder measures = solver.getMeasures();
      //float rTime = measures.getTimeCount();
      //System.out.printf("time since start: %s\n", rTime);
      //float bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
      solver.printStatistics();
      //measures = solver.getMeasures();
      //bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
   }

}
